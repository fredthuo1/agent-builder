import type { AppPlan, EntitySpec, FieldSpec, PlannerMode } from "./types";

function toAppName(prompt: string) {
  const base = prompt
    .trim()
    .slice(0, 48)
    .replace(/[^a-zA-Z0-9 ]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  return base ? base : "Generated App";
}

function normalizeEntityName(name: string) {
  const cleaned = name.trim().toLowerCase().replace(/[^a-z0-9_ ]/g, "").replace(/\s+/g, "_");
  return cleaned || "entity";
}

function ensureIdField(fields: FieldSpec[]) {
  // We do NOT include id in user fields; backend always has id INTEGER PRIMARY KEY AUTOINCREMENT.
  return fields;
}

function parseFieldsFromPrompt(prompt: string): FieldSpec[] {
  // heuristic: look for "fields:" then comma-separated "name (type)" items
  const m = prompt.match(/fields?\s*:\s*([^.\n]+)/i);
  const chunk = m?.[1] ?? "";
  const parts = chunk.split(",").map((s) => s.trim()).filter(Boolean);

  const fields: FieldSpec[] = [];

  for (const p of parts) {
    // "frequency (daily, weekly)" => enum
    const paren = p.match(/^([a-zA-Z0-9_ ]+)\s*\(([^)]+)\)\s*$/);
    if (paren) {
      const name = paren[1]!.trim();
      const inside = paren[2]!.trim();

      const enumCandidates = inside.split(/[\s,]+/).map((x) => x.trim()).filter(Boolean);
      const hasEnumWords =
        enumCandidates.length >= 2 &&
        enumCandidates.every((x) => /^[a-zA-Z0-9_]+$/.test(x)) &&
        !["string", "number", "boolean", "date", "text"].includes(inside.toLowerCase());

      if (hasEnumWords) {
        fields.push({ name: normalizeEntityName(name), type: "enum", enumValues: enumCandidates });
        continue;
      }

      const t = inside.toLowerCase();
      if (t.includes("number") || t.includes("int") || t.includes("float")) {
        fields.push({ name: normalizeEntityName(name), type: "number" });
      } else if (t.includes("bool")) {
        fields.push({ name: normalizeEntityName(name), type: "boolean" });
      } else if (t.includes("date") || t.includes("time")) {
        fields.push({ name: normalizeEntityName(name), type: "date" });
      } else if (t.includes("text")) {
        fields.push({ name: normalizeEntityName(name), type: "text" });
      } else {
        fields.push({ name: normalizeEntityName(name), type: "string" });
      }
      continue;
    }

    // "streak (number)" is handled above; otherwise infer by keywords
    const name = normalizeEntityName(p);
    let type: FieldSpec["type"] = "string";
    if (name.includes("date") || name.includes("time")) type = "date";
    if (name.includes("is_") || name.startsWith("has_") || name.includes("active")) type = "boolean";
    if (name.includes("count") || name.includes("qty") || name.includes("quantity") || name.includes("number")) type = "number";
    fields.push({ name, type });
  }

  // default fallback if nothing found
  if (fields.length === 0) {
    fields.push({ name: "title", type: "string", required: true });
    fields.push({ name: "status", type: "enum", enumValues: ["todo", "doing", "done"] });
  }

  return ensureIdField(fields);
}

export function makeLocalPlan(prompt: string, mode: PlannerMode = "local"): AppPlan {
  // attempt to infer entity name: first noun-ish word or default "item"
  const entityGuessMatch = prompt.match(/build\s+(an?\s+)?([a-zA-Z][a-zA-Z0-9 ]{2,40})/i);
  let entityName = "item";
  if (entityGuessMatch?.[2]) {
    const raw = entityGuessMatch[2]
      .replace(/(app|application|tracker|manager|dashboard|system).*/i, "")
      .trim();
    if (raw) entityName = raw.split(/\s+/)[0] || entityName;
  }

  const fields = parseFieldsFromPrompt(prompt);

  const entity: EntitySpec = {
    name: normalizeEntityName(entityName),
    title: entityName.replace(/^\w/, (c) => c.toUpperCase()) + "s",
    fields,
  };

  return {
    appName: toAppName(prompt),
    description: "Generated by Agent Builder",
    generationMode: mode,
    entities: [entity],
  };
}